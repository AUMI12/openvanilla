希望某天會變成 *泛用* 自動選字引擎， *不* 針對個別輸入法實作特定功能。程式碼見 trunk/Experiments/Tobacco/ 。基於軟體工程理論的設計考量，請參考 Contribute2CHI2006 的說法，那將是進行重構時的指標。 

操作介面在 PredictorSingleton（換句話說輸入法模組應該只要叫用這個就好），負責和 SQLite 銜接的是 DictionarySingleton，資料結構則是 Token、Vocabulary、Candidate，演算法放在 BiGram 裡。最近會開始考慮和 [SRILM http://www.speech.sri.com/projects/srilm/] 橋接，不再自己造輪子，見 http://rt.openfoundry.org/Foundry/Project/Tracker/Display.html?Queue=196&id=13319 。

把每次輸入的 keystroke 和由 0 算起的位置（注意，這個不是指游標當時的位置，而是組完字之後的位置。舉例來說，「輸入5j/」這樣的狀態，keystroke 是 "5j/"，位置是 2）丟給 PredictorSingleton::setTokenVector，然後再拿 PredictorSingleton::composedString 就好了。

總之，還有很多地方需要重構，目前只是暫時把外殼生出來。（警告：它真的很醜。）

實際使用範例請見 trunk/Modules/OVIMTobacco/ ，其中尚未提供的功能，若依預計實作的優先順序排列，大致上有「隨打隨組（auto-compose）」、「各種鍵盤配置（如注音的許氏鍵盤）切換」、「萬用字元查詢」、「輸入法鍵碼反查」、「整合 OVIMRomanNew」等等。

另外，目前最需要幫忙的是把注音以外的輸入法辭庫和 cin 轉換成對應的 database tables。Database schema 的說明請看 DictionarySingleton.cpp 裡的註解。理論上現在只要照著那個規定生個 SQLite3 db 出來應該就能動了，OVIMTobacco 本身的程式碼毋需修改。

API 操作示範：

 #include "PredictorSingleton.h"
 ...
 OVBuffer* b;
 int position;
 ...
 const char* dbFilePath = "/foo/bar.db";
 const char* inputMethodId = "cj";
 /// inputMethodId 大概會用輸入法模組的 Identifier（.cin 的 ename？),
 /// 要注意的是這要用來辨認 database table 名稱，兩者必須一致。
 PredictorSingleton* predictor =
     PredictorSingleton::getInstance(dbFilePath, inputMethodId);
 /// 在任何地方想用 PredictorSingleton 時都請用 getInstance。
 /// 只有在輸入法 destroy 的時候才需要呼叫
 /// PredictorSingleton::lostInstance();
 /// 另外，如果只是暫時把輸入法切掉，可以選擇使用
 /// PredictorSingleton::clearAll();
 /// （如果不希望 buffer 裡的東西還留著的話）
 ...
 /// 假設 buffer 內容是 "輸入5j/"
 string keystrokes("5j/");
 position = 2;
 predictor->setTokenVector(keystrokes, position);
 /// 因為把「現在要處理的 keystrokes」從 buffer 裡切分出來
 /// 並判斷「組完字的位置」（通常是 "游標位置 - keystrokes 長度"）
 /// 這件事有點討厭，
 /// 所以留在外頭讓輸入法模組自己想辦法，不放進這個函式裡。
 b->clear()->append(predictor->composedString.c_str());
 /// 更新的方式是每次都覆蓋整個 buffer。
 position++;
 /// 下次組字的位置向右移動一個單位
 b->update(position, position-1, position);
 /// 設定游標位置與反白底線範圍
 ...
