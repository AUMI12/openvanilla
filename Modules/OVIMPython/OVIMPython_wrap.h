/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.31
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#ifndef SWIG_OVIMPython_WRAP_H_
#define SWIG_OVIMPython_WRAP_H_

#include <map>
#include <string>


class SwigDirector_OVBase : public OVBase, public Swig::Director {

public:
    SwigDirector_OVBase(PyObject *self);
    virtual ~SwigDirector_OVBase();


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;
};


class SwigDirector_OVKeyCode : public OVKeyCode, public Swig::Director {

public:
    SwigDirector_OVKeyCode(PyObject *self);
    virtual ~SwigDirector_OVKeyCode();
    virtual int code();
    virtual int isShift();
    virtual int isCapslock();
    virtual int isCtrl();
    virtual int isAlt();
    virtual int isOpt();
    virtual int isCommand();
    virtual int isNum();
    virtual int isFunctionKey();


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVKeyCode doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[9];
#endif

};


class SwigDirector_OVBuffer : public OVBuffer, public Swig::Director {

public:
    SwigDirector_OVBuffer(PyObject *self);
    virtual ~SwigDirector_OVBuffer();
    virtual OVBuffer *clear();
    virtual OVBuffer *append(char const *s);
    virtual OVBuffer *send();
    virtual OVBuffer *update();
    virtual OVBuffer *update(int cursorPos, int markFrom = -1, int markTo = -1);
    virtual int isEmpty();


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVBuffer doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[8];
#endif

};


class SwigDirector_OVCandidate : public OVCandidate, public Swig::Director {

public:
    SwigDirector_OVCandidate(PyObject *self);
    virtual ~SwigDirector_OVCandidate();
    virtual OVCandidate *clear();
    virtual OVCandidate *append(char const *s);
    virtual OVCandidate *hide();
    virtual OVCandidate *show();
    virtual OVCandidate *update();
    virtual int onScreen();


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVCandidate doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[6];
#endif

};


class SwigDirector_OVDictionary : public OVDictionary, public Swig::Director {

public:
    SwigDirector_OVDictionary(PyObject *self);
    virtual ~SwigDirector_OVDictionary();
    virtual int keyExist(char const *key);
    virtual int getInteger(char const *key);
    virtual int setInteger(char const *key, int value);
    virtual char const *getString(char const *key);
    virtual char const *setString(char const *key, char const *value);
    virtual int getIntegerWithDefault(char const *key, int value);
    virtual char const *getStringWithDefault(char const *key, char const *value);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVDictionary doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[7];
#endif

};


class SwigDirector_OVService : public OVService, public Swig::Director {

public:
    SwigDirector_OVService(PyObject *self);
    virtual ~SwigDirector_OVService();
    virtual void beep();
    virtual void notify(char const *msg);
    virtual char const *locale();
    virtual char const *userSpacePath(char const *modid);
    virtual char const *pathSeparator();
    virtual char const *toUTF8(char const *encoding, char const *src);
    virtual char const *fromUTF8(char const *encoding, char const *src);
    virtual char const *UTF16ToUTF8(unsigned short *src, int len);
    virtual int UTF8ToUTF16(char const *src, unsigned short **rcvr);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVService doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[9];
#endif

};


class SwigDirector_OVInputMethodContext : public OVInputMethodContext, public Swig::Director {

public:
    SwigDirector_OVInputMethodContext(PyObject *self);
    virtual ~SwigDirector_OVInputMethodContext();
    virtual void start(OVBuffer *arg0, OVCandidate *arg1, OVService *arg2);
    virtual void clear();
    virtual void end();
    virtual int keyEvent(OVKeyCode *arg0, OVBuffer *arg1, OVCandidate *arg2, OVService *arg3);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVInputMethodContext doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[4];
#endif

};


class SwigDirector_OVModule : public OVModule, public Swig::Director {

public:
    SwigDirector_OVModule(PyObject *self);
    virtual ~SwigDirector_OVModule();
    virtual char const *moduleType();
    virtual char const *identifier();
    virtual char const *localizedName(char const *locale);
    virtual int initialize(OVDictionary *moduleCfg, OVService *srv, char const *modulePath);
    virtual void update(OVDictionary *moduleCfg, OVService *srv);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVModule doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[5];
#endif

};


class SwigDirector_OVInputMethod : public OVInputMethod, public Swig::Director {

public:
    SwigDirector_OVInputMethod(PyObject *self);
    virtual ~SwigDirector_OVInputMethod();
    virtual char const *moduleType();
    virtual char const *identifier();
    virtual char const *localizedName(char const *locale);
    virtual int initialize(OVDictionary *moduleCfg, OVService *srv, char const *modulePath);
    virtual void update(OVDictionary *moduleCfg, OVService *srv);
    virtual OVInputMethodContext *newContext();


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVInputMethod doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[6];
#endif

};


class SwigDirector_OVOutputFilter : public OVOutputFilter, public Swig::Director {

public:
    SwigDirector_OVOutputFilter(PyObject *self);
    virtual ~SwigDirector_OVOutputFilter();
    virtual char const *moduleType();
    virtual char const *identifier();
    virtual char const *localizedName(char const *locale);
    virtual int initialize(OVDictionary *moduleCfg, OVService *srv, char const *modulePath);
    virtual void update(OVDictionary *moduleCfg, OVService *srv);
    virtual char const *process(char const *source, OVService *srv);


/* Internal Director utilities */
public:
    bool swig_get_inner(const char* name) const {
      std::map<std::string, bool>::const_iterator iv = inner.find(name);
      return (iv != inner.end() ? iv->second : false);
    }

    void swig_set_inner(const char* name, bool val) const
    { inner[name] = val;}

private:
    mutable std::map<std::string, bool> inner;


#if defined(SWIG_PYTHON_DIRECTOR_VTABLE)
/* VTable implementation */
    PyObject *swig_get_method(size_t method_index, const char *method_name) const {
      PyObject *method = vtable[method_index];
      if (!method) {
        swig::PyObject_var name = PyString_FromString(method_name);
        method = PyObject_GetAttr(swig_get_self(), name);
        if (method == NULL) {
          std::string msg = "Method in class OVOutputFilter doesn't exist, undefined ";
          msg += method_name;
          Swig::DirectorMethodException::raise(msg.c_str());
        }
        vtable[method_index] = method;
      };
      return method;
    }
private:
    mutable swig::PyObject_var vtable[6];
#endif

};


#endif
